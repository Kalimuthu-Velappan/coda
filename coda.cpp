//writer nishant.pamnani@gmail.com


#define PACKAGE "coda"
#define PACKAGE_VERSION "1.0"
#define MIN_STR_SIZE 4

#include "coda.h"
#include "coda_ehframe.h"

#ifdef CODA_DISASSEMBLY
#include <dis-asm.h>
#endif

#include <stdarg.h>

#ifdef CODA_DEBUG
bool coda_debug = true;
#else
bool coda_debug = false;
#endif

extern "C" char *
__cxa_demangle (const char *mangled_name, char *output_buffer,
                size_t *length, int *status);

CoreObject&
CoreObject::GetCoreObject(char const *cfname)
{
  static CoreObject cobj(cfname); 
  return cobj;
}

CoreObject::CoreObject(char const *cfname):m_corefile(cfname),
                                           m_current_thread(1),
                                           m_pthreads(false),
                                           m_demangle(false),
                                           m_interactive_mode(false),
                                           m_found_nt_file(false)
{
  m_corefile >> m_core_ehdr;
  if (!ElfHdr(m_core_ehdr))
  {
    std::cerr << "Not an elf object!\n";
    exit(1);
  }
  CheckArch();
  IsCoreFile();
  ExtractPhdrs();
  ExtractProcessVitals();
  ExtractSharedLibraries();
  Process_NT_FILE_Note();
}

void
CoreObject::Process_NT_FILE_Note()
{
  if(!m_found_nt_file)
  {
    return;
  }

  char *cptr = m_nt_file_sec;
  long count = *(long*)cptr;
  long pgsize = *(long*)(cptr + sizeof(long)); 


  std::vector<nt_file_element> v_nt_file_elem(count);
  std::vector<char*> v_filename(count);

  cptr += 2 * sizeof(long); 
  for (long ndx = 0; ndx < count; ++ndx, cptr += sizeof(nt_file_element))
  {
    v_nt_file_elem[ndx] = *(nt_file_element*)cptr;
  }
 
  for (long ndx = 0; ndx < count; ++ndx)
  {
    v_filename[ndx] = cptr;
    while (*cptr++ != '\0');
  }
  
  for (long ndx =0; ndx < count; ++ndx)
  {
    SetOrModifySegmentName(v_nt_file_elem[ndx].start,v_filename[ndx]);
  }
 
}

void
CoreObject::SetOrModifySegmentName(uint64_t va, const char *segname)
{
  ObjectEntry *oe = FindObjectEntry(va);

  if (!oe)
    return;
  oe->filename = segname;
}

void 
CoreObject::WelcomeMessage()
{
  std::cout << "Welcome to coda interactive command line."
            << std::endl;
  std::cout << "THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND."
            << std::endl;
  std::cout << "Supported on x86_64-linux."
            << std::endl;
  std::cout << "Coredump generated by command line => "
            << m_commandline
            << std::endl;
}


void 
CoreObject::ExtractSharedLibraries()
{
  ObjectEntry *oe = FindObjectEntry(m_aux_phdr_va);

  if (!oe) 
    return;

  ElfW(Ehdr) exe_ehdr;
  //elf header of crashed exe 
  m_corefile >> File::Offset(oe->phdr->p_offset) >> exe_ehdr;

  //phdr table of crashed exe 
  ElfW(Phdr) * phdr_arr = new ElfW(Phdr)[exe_ehdr.e_phnum];
  m_corefile >> File::Offset(oe->phdr->p_offset + m_aux_phdr_va - oe->phdr->p_vaddr)
             >> File::Units(exe_ehdr.e_phnum) >> phdr_arr;


  uint64_t exe_phdr_va = 0;
  ElfW(Phdr) *exe_dyphdr = NULL;
  for(int ndx = 0; ndx < exe_ehdr.e_phnum; ndx++ )
  {
    if(PT_PHDR == phdr_arr[ndx].p_type) 
    {
      exe_phdr_va = phdr_arr[ndx].p_vaddr;
    }
    if (PT_DYNAMIC == phdr_arr[ndx].p_type) 
    {
       exe_dyphdr = &phdr_arr[ndx];
    }
  }
 
  uint64_t dt_debug_va;

  if (NULL == exe_dyphdr) 
    goto out;

  dt_debug_va = ExtractDT_DEBUG(m_aux_phdr_va - exe_phdr_va, 
                                (m_aux_phdr_va - exe_phdr_va) 
                                + exe_dyphdr->p_vaddr);
  if (0 == dt_debug_va)
    goto out;

  AccessSharedLibsNames(dt_debug_va);

out:
  delete [] phdr_arr;
}

void 
CoreObject::AccessSharedLibsNames(uint64_t va)
{
  ObjectEntry *oe = FindObjectEntry(va);

  if (!oe) 
    return;

  uint64_t rdebug_offset = (va - oe->phdr->p_vaddr) + oe->phdr->p_offset;

  struct r_debug rd;
  m_corefile >> File::Offset(rdebug_offset) >> rd;

  struct link_map lm;
  va = (uint64_t)rd.r_map;
  do
  {
    char libname[LIB_NAME_LEN];
    oe = FindObjectEntry(va);
    if (!oe) 
      continue;

    off_t linkmap_offset = (va - oe->phdr->p_vaddr) 
                                 + oe->phdr->p_offset;
    memset(&lm,0,sizeof(struct link_map));
    m_corefile >> File::Offset(linkmap_offset) >> lm;

    va = (uint64_t)lm.l_name;
    oe = FindObjectEntry(va);
    if (!oe) 
      continue;

    off_t lib_offset = (va - oe->phdr->p_vaddr) + oe->phdr->p_offset;
    m_corefile >> File::Offset(lib_offset) 
                >> File::Units(LIB_NAME_LEN) >> libname;

    if (libname[0]) 
    {
      if (!m_pthreads)
      {
        if (!!strstr(libname,"pthread"))
          m_pthreads = true;
      }
      SetSegmentName((uint64_t)lm.l_ld, (uint64_t)lm.l_addr, libname);
    }
  }while(!!(va = (uint64_t )lm.l_next));
}

void 
CoreObject::SetSegmentName(uint64_t va, uint64_t ba, const char *libname)
{
  ObjectEntry *oe = FindObjectEntry(va);

  if (!oe)
    return;

  off_t dyntbl_offset = (va - oe->phdr->p_vaddr) + oe->phdr->p_offset;
  ElfW(Dyn) dyn;
  m_corefile >> File::Offset(dyntbl_offset);

  uint64_t va_strtab = 0;
  uint64_t va_symtab = 0;
  uint64_t va_hashtab = 0;
  uint64_t strtab_size = 0;
  do 
  {
    m_corefile >> dyn;
    if (DT_STRTAB == dyn.d_tag) {
      va_strtab = dyn.d_un.d_ptr;
    }
    if (DT_SYMTAB == dyn.d_tag) {
      va_symtab = dyn.d_un.d_ptr;
    }
    if (DT_STRSZ == dyn.d_tag) {
      strtab_size = dyn.d_un.d_val;
    }
    if (DT_GNU_HASH == dyn.d_tag) {
      va_hashtab = dyn.d_un.d_ptr;
    }
  } while (DT_NULL != dyn.d_tag);

  ObjectEntry *oe2 = FindObjectEntry(va_symtab,false);
  if (!oe2) 
    return;
  oe->strtab      = oe2->strtab = va_strtab;
  oe->symtab      = oe2->symtab = va_symtab;
  oe->hashtab     = oe2->hashtab = va_hashtab;
  oe->strtab_size = oe2->strtab_size = strtab_size;
  oe->base_addr   = oe2->base_addr = ba;
  oe2->filename = libname;
  oe->filename = libname;
}

uint64_t 
CoreObject::ExtractDT_DEBUG(uint64_t ba, uint64_t va)
{

  ObjectEntry *oe = FindObjectEntry(va);

  if (!oe) 
    return 0;

  m_corefile >> File::Offset(va - oe->phdr->p_vaddr + oe->phdr->p_offset);

  ElfW(Dyn) dyn;
  uint64_t va_to_return = 0;
  uint64_t va_strtab = 0;
  uint64_t va_symtab = 0;
  uint64_t va_hashtab = 0;
  uint64_t strtab_size = 0;
  do 
  {
    m_corefile >> dyn;
    if (DT_STRTAB == dyn.d_tag) {
      va_strtab = dyn.d_un.d_ptr;
    }
    if (DT_SYMTAB == dyn.d_tag) {
      va_symtab = dyn.d_un.d_ptr;
    }
    if (DT_STRSZ == dyn.d_tag) {
      strtab_size = dyn.d_un.d_val;
    }
    if (DT_GNU_HASH == dyn.d_tag) {
      va_hashtab = dyn.d_un.d_ptr;
    }
    if (DT_DEBUG == dyn.d_tag) 
    {
       va_to_return = dyn.d_un.d_ptr;
    }
  } while (DT_NULL != dyn.d_tag);

  ObjectEntry *oe2 = FindObjectEntry(va_symtab,false);
  if (!oe2) 
    return va_to_return;
  oe->strtab      = oe2->strtab = va_strtab;
  oe->symtab      = oe2->symtab = va_symtab;
  oe->hashtab     = oe2->hashtab = va_hashtab;
  oe->strtab_size = oe2->strtab_size = strtab_size;
  oe->base_addr = oe2->base_addr = ba;
  oe2->filename = m_progname;
  oe->filename = m_progname;
  return va_to_return;
}

void 
CoreObject::ExtractProcessVitals()
{
  char *note_segment = new char[m_note_phdr->p_filesz];

  m_corefile >> File::Offset(m_note_phdr->p_offset) 
                   >> File::Units(m_note_phdr->p_filesz) >> note_segment;

  char * cptr = note_segment;

  while ( (cptr - note_segment) < m_note_phdr->p_filesz ) 
  {

    ElfW(Nhdr) *nhdr = (ElfW(Nhdr) *)cptr;

    ElfW(Word)  newnamesize = ((nhdr->n_namesz) + 3) & (~3);
    ElfW(Word) descnamesize = ((nhdr->n_descsz) + 3) & (~3);

    if (NT_PRSTATUS == nhdr->n_type) 
    {
      elf_prstatus *eprs =
      reinterpret_cast<elf_prstatus*>(cptr + sizeof(ElfW(Nhdr)) + newnamesize);
      m_pr_ctx.m_vprst.push_back(eprs);
    }
    else if (NT_AUXV == nhdr->n_type) 
    {
      ElfW(auxv_t) *auxe = 
                 (ElfW(auxv_t)*)(cptr + sizeof(ElfW(Nhdr)) + newnamesize);
      while(AT_NULL != auxe->a_type)
      {
        if (AT_PHDR == auxe->a_type) {
          m_aux_phdr_va = auxe->a_un.a_val;
          break;
        }
        ++auxe;
      }
    }
    else if (NT_PRPSINFO == nhdr->n_type || NT_PSINFO == nhdr->n_type) 
    {
      m_progname 
                 =  cptr
                 + sizeof(ElfW(Nhdr))
                 + newnamesize
                 + offset_of(struct elf_prpsinfo, pr_fname);
      m_commandline 
                 =  cptr
                 + sizeof(ElfW(Nhdr))
                 + newnamesize
                 + offset_of(struct elf_prpsinfo, pr_psargs);
      m_pr_ctx.m_prinfo = reinterpret_cast<elf_prpsinfo*>
                      (cptr + sizeof(ElfW(Nhdr)) + newnamesize);
    } 
#ifdef NT_FILE
    else if (NT_FILE == nhdr->n_type)
    {
      m_nt_file_sec = cptr + sizeof(ElfW(Nhdr)) + newnamesize;
      m_found_nt_file = true;
    }
#endif
    cptr += sizeof(ElfW(Nhdr)) + newnamesize + descnamesize;
  }
}

void 
CoreObject::ExtractPhdrs()
{
  ElfW(Phdr) * phdr_arr   = new ElfW(Phdr)[m_core_ehdr.e_phnum];

  m_corefile >> File::Offset(m_core_ehdr.e_phoff) 
                   >> File::Units(m_core_ehdr.e_phnum) >> phdr_arr;

  bool not_mini_dump = true;
  for (unsigned ndx = 0; ndx < m_core_ehdr.e_phnum; ++ndx)
  {
    if ( not_mini_dump 
         && 
         (PT_NOTE != phdr_arr->p_type) 
         && 
         (phdr_arr->p_filesz != phdr_arr->p_memsz)
       )
    {
      not_mini_dump = false;
    }

    if(PT_NOTE != phdr_arr->p_type)
    {
      ObjectEntry *tmp = new ObjectEntry; 

      if ((phdr_arr->p_flags & (PF_R | PF_W)) == (PF_R | PF_W))
        tmp->access= "[RW ";
      else if (phdr_arr->p_flags & PF_R)
        tmp->access = "[RO ";
      else 
        tmp->access = "[Non-Readable ";

      if (phdr_arr->p_flags & PF_X)
        tmp->access += "TEXT]:";
      else 
        tmp->access += "DATA]:";

      tmp->phdr = phdr_arr;
      tmp->symtab = 0;
      tmp->strtab = 0;
      tmp->symtab_loaded = false;
      tmp->cant_load_symtab = false;
      tmp->sym_count = 0;
      tmp->strtab_size = 0;
      tmp->base_addr = 0;
      m_object_map.push_back(tmp);
    }
    else
    {
      m_note_phdr = phdr_arr;
    }
    ++phdr_arr;
  }
 
  m_mini_dump = (m_core_ehdr.e_phnum < 2) ? true : !not_mini_dump; 
}

CoreObject::ObjectEntry *
CoreObject::FindObjectEntry(uint64_t va, bool filesz)
{
  unsigned start = 0; 
  unsigned end = m_object_map.size();
  

  unsigned mid; 
  while((end - start) > 1)
  {
    mid = (start + end)/2;
    if (va < m_object_map[mid]->phdr->p_vaddr)
      end = mid;
    else 
      start = mid;
  }

  mid = (start + end)/2;

  if (mid >= m_object_map.size())
    return NULL;

  if ( (m_object_map[mid]->phdr->p_vaddr <= va)
       &&
       (
         ( filesz 
           && 
           (va < (m_object_map[mid]->phdr->p_vaddr + 
                  m_object_map[mid]->phdr->p_filesz)
           )
         )
         ||
         ( !filesz 
           && 
           (va < (m_object_map[mid]->phdr->p_vaddr + 
                  m_object_map[mid]->phdr->p_memsz)
           )
         )
       )
     )
  {
    return m_object_map[mid];
  }
  return NULL;
}

static int 
CompareSymbols(const void *vp1, const void *vp2)
{
    const ElfW(Sym) *sym1 = (ElfW(Sym) *)vp1;
    const ElfW(Sym) *sym2 = (ElfW(Sym) *)vp2;
  
    if (sym1->st_value < sym2->st_value)
      return -1;
    else if (sym1->st_value > sym2->st_value)
      return 1;
    else 
      return 0;
}

RetCode 
CoreObject::Addr2Name(uint64_t va, std::string &symname)
{
  ObjectEntry *oe = FindObjectEntry(va,false);
  if (!oe) 
  {
    symname = "?? <INVALID ADDRESS>";
    return FALIURE;
  }

  RetCode rc = PART_SUCCESS;
  if (!oe->symtab || !oe->strtab || oe->cant_load_symtab)
  {
    goto out;
  }

  if (!oe->symtab_loaded) 
  {
 
    uint64_t strtab_size = oe->strtab_size;
    char *symtab;
    char *strtab;
    
    ObjectEntry *str_oe = FindObjectEntry(oe->strtab);
    if(!str_oe)  
    {
      oe->cant_load_symtab = true;
      goto out;
    }
    ObjectEntry *sym_oe = FindObjectEntry(oe->symtab);
    if(!sym_oe)
    {
      oe->cant_load_symtab = true;
      goto out;
    }
    ObjectEntry *hash_oe = FindObjectEntry(oe->hashtab);
    if(!hash_oe)
    {
      oe->cant_load_symtab = true;
      goto out;
    }

    uint32_t bucketcount;
    uint32_t symbias;
    uint32_t bitmask_nwords;
 
    m_corefile  >> File::Offset(oe->hashtab - 
                      hash_oe->phdr->p_vaddr + 
                      hash_oe->phdr->p_offset) >> bucketcount;

    m_corefile  >> File::Offset(oe->hashtab + 4 - 
                      hash_oe->phdr->p_vaddr + 
                      hash_oe->phdr->p_offset) >> symbias;

    m_corefile  >> File::Offset(oe->hashtab + 4 + 4- 
                      hash_oe->phdr->p_vaddr + 
                      hash_oe->phdr->p_offset) >> bitmask_nwords;
     
    uint32_t sym_count = 0;
    for (uint32_t i=bucketcount;i > 0;i--)
    {
      uint64_t bucket = oe->hashtab 
                          + 16 
                          + 4 * m_core_ehdr.e_ident[EI_CLASS] * bitmask_nwords 
                          + (i * 4 - 4);
      m_corefile  >> File::Offset(bucket - 
                    hash_oe->phdr->p_vaddr + 
                    hash_oe->phdr->p_offset) >> sym_count;
     
      if (sym_count != 0) 
        break;
    }

    if (0 == sym_count) 
    {
      oe->cant_load_symtab = true;
      goto out;
    }

    strtab =  new char[strtab_size];
    m_corefile  >> File::Offset(oe->strtab - 
                      str_oe->phdr->p_vaddr + 
                      str_oe->phdr->p_offset)
                >> File::Units(strtab_size) >> strtab;
  
    oe->strtab = (uint64_t)strtab;

    symtab =  new char[(sym_count - symbias + 2) * sizeof(ElfW(Sym))];
    m_corefile  >> File::Offset(oe->symtab + (sizeof(ElfW(Sym)) * symbias) - 
                      sym_oe->phdr->p_vaddr + 
                      sym_oe->phdr->p_offset)
                >> File::Units((sym_count - symbias + 2) * 
                                sizeof(ElfW(Sym))) >> symtab;


    qsort(symtab,(sym_count - symbias + 2),sizeof(ElfW(Sym)),CompareSymbols);
    oe->symtab = (uint64_t)symtab;
    oe->sym_count = sym_count - symbias + 2;
    oe->symtab_loaded = true;
  }

  rc = FindSymbol(oe,va,symname);
out:
  if (PART_SUCCESS == rc)
    symname = oe->access + oe->filename;
  return rc;
}

RetCode 
CoreObject::FindSymbol(ObjectEntry *oe, uint64_t va, std::string &symname)
{
  ElfW(Sym) *symtab = (ElfW(Sym) *)oe->symtab;
  uint64_t base_addr = oe->base_addr;
  uint32_t start = 0;
  uint32_t end = oe->sym_count;

  uint32_t mid;
  while((end - start) > 1)
  {
    mid = (start + end)/2;
    if (va < (symtab[mid].st_value + base_addr))
      end = mid;
    else
      start = mid;
  }

  mid = (start + end)/2;
  if (mid >= oe->sym_count)
    return PART_SUCCESS;

  if (va >= (symtab[mid].st_value + base_addr))
  {
    char *strtab = (char*)oe->strtab;

    char offset[16] = {' '};
    if (va - (base_addr + symtab[mid].st_value))
      sprintf(offset,"+0x%lx ",(va-(base_addr + symtab[mid].st_value)));

    if (m_demangle) 
    {
      char *demangled_name 
             = __cxa_demangle(&strtab[symtab[mid].st_name],NULL,NULL,NULL);
      if(demangled_name)
      {
        symname = demangled_name;
        free(demangled_name);
        symname += offset + oe->access + oe->filename;
        return SUCCESS;
      }
    }
    symname = std::string(&strtab[symtab[mid].st_name])  
             + offset + oe->access + oe->filename;
    return SUCCESS;
  } 
  return PART_SUCCESS;
}

void 
CoreObject::ShowMemoryMap()
{
  int linecount = 0;
  for(unsigned ndx = 0; ndx < m_object_map.size(); ++ndx)
  {
    std::cout  
      << "0x" << std::hex << m_object_map[ndx]->phdr->p_vaddr
      << " - 0x" << std::hex << m_object_map[ndx]->phdr->p_vaddr 
                              + m_object_map[ndx]->phdr->p_memsz
      << " " << m_object_map[ndx]->access + m_object_map[ndx]->filename
      << std::endl;
    Paginate(m_interactive_mode,++linecount);
  }
}

void 
CoreObject::ShowBT(bool regs)
{

  const elf_prstatus *eprs = m_pr_ctx.m_vprst[m_current_thread -1];
  const user_regs_struct *urs =
                 reinterpret_cast<const user_regs_struct *>(eprs->pr_reg);
  EHFrame eh(this, m_corefile, regs);
  eh.PrintBT(urs);
}

void
CoreObject::ShowBTAll()
{
  elf_prpsinfo *prinfo = m_pr_ctx.m_prinfo;
  bool visited = false;
  std::vector<elf_prstatus*>::const_iterator citer = m_pr_ctx.m_vprst.begin();

  for(;citer != m_pr_ctx.m_vprst.end();++citer)
  { 
    const elf_prstatus *eprs = *citer;
    
    if (!visited) 
    {
      if (eprs->pr_info.si_signo) 
      {
        std::cout << std::dec << "FAULTing Thread[" << eprs->pr_pid << "] ";
        std::cout << std::dec << "SIGNAL NO[" << eprs->pr_info.si_signo << "]";
      }
      std::cout << " PID[" << std::dec << prinfo->pr_pid << "]\n";
      visited = true;
    }
    std::cout << "\nLWP => " << std::dec << eprs->pr_pid;
    const user_regs_struct *urs =
                 reinterpret_cast<const user_regs_struct *>(eprs->pr_reg);
    // It is not reliable to print thread-id when core is not generated 
    // as a side-effect of a signal i.e. it is not generated by kernel but some 
    // core generation utility like gcore. 
    if(m_pthreads && eprs->pr_info.si_signo) 
      std::cout << " Thread ID => " << std::hex << "0x"<< urs->fs_base << "\n";
    else
      std::cout << "\n";

    EHFrame eh(this, m_corefile, true);
    eh.PrintBT(urs);
  }
}

void 
CoreObject::ShowThrList()
{
  std::vector<elf_prstatus*>::const_iterator citer = m_pr_ctx.m_vprst.begin();

  int kount = 1;
  for(;citer != m_pr_ctx.m_vprst.end();++citer)
  { 
    const elf_prstatus *eprs = *citer;
    
    std::cout << "[" << std::dec << kount++ << "] ";
    std::cout << "LWP => " << std::dec << eprs->pr_pid << " ";
    const user_regs_struct *urs =
                 reinterpret_cast<const user_regs_struct *>(eprs->pr_reg);
    // It is not reliable to print thread-id when core is not generated 
    // as a side-effect of a signal i.e. it is not generated by kernel but some 
    // core generation utility like gcore. 
    if(m_pthreads && eprs->pr_info.si_signo) 
      std::cout << "Thread ID => " << std::hex << "0x"<< urs->fs_base << " ";
    std::cout << "RIP => " << std::hex << "0x"<< urs->rip << " ";
    EHFrame eh(this, m_corefile);
    FrameInfo *fi = eh.FindFrameInfo(urs->rip);
    if (fi != NULL)
      std::cout <<"("<< std::hex <<"0x"<< fi->pc <<" - 0x"<< fi->pc_end <<")";
    std::cout << "\n";
    
  }
}

int coda_fprintf (void *, const char* format, ...)
{
  char str[256];

  int rc;
  va_list args;

  va_start(args,format);
  rc = vsnprintf(str,255,format,args);

  std::cout << str;

  return rc;
}

#ifdef CODA_DISASSEMBLY
void start_disassembly(uint64_t start_va, 
                            uint64_t end_va, 
                                disassemble_info *pdinfo,
                                  bool interactive_mode)
{
  uint64_t va = start_va;
  int linecount = 0;
  std::string label;
  CoreObject::GetCoreObject().Addr2Name(va,label);
  std::cout << label << ":" << std::endl;
  
  while(va < end_va)
  {
    int size;
    std::cout << "0x" << std::setw(16) 
              << std::setfill('0') 
              << std::right
              << std::hex << va << " ";
    size = print_insn_i386_att(va,pdinfo);
    if (0 == size || -1 == size)
    {
      std::cout << "\nDisassembly Stopped\n";
      break;
    }
    std::cout << std::endl;
    Paginate(interactive_mode,++linecount);
    va += size;
  }
}
#endif

void
CoreObject::SwitchToThread(size_t threadno)
{

  if ((CURRENT_THREAD != threadno) && 
      (threadno == 0 || threadno > m_pr_ctx.m_vprst.size()))
  {
    std::cout << "Invalid thread ID\n";
    return;
  }

  if (CURRENT_THREAD != threadno)
  {
    m_current_thread = threadno;
    std::cout << std::dec << "Switching to thread " << m_current_thread;
  }
  else
    std::cout << std::dec << "Current thread is " << m_current_thread;

  const elf_prstatus *eprs = m_pr_ctx.m_vprst[m_current_thread - 1];
  std::cout << " LWP => " << std::dec 
                          << eprs->pr_pid
                          << " ";
  if(m_pthreads && eprs->pr_info.si_signo) 
  {
    const user_regs_struct *urs =
                 reinterpret_cast<const user_regs_struct *>(eprs->pr_reg);
    std::cout << "Thread ID => " << std::hex << "0x"<< urs->fs_base << " ";
  }
  std::cout << std::endl;
}

void 
CoreObject::ShowDisassembly(uint64_t va)
{

#ifndef CODA_DISASSEMBLY
  std::cout << "Disassembly not enabled, "
                "recompile coda with CODA_DISASSEMBLY macro\n";
#else
  EHFrame eh(this, m_corefile);

  FrameInfo *fi = eh.FindFrameInfo(va);
 
  if (NULL == fi)
  {
    std::cout << "Disassembly failed: " << "0x"<< std::hex << va 
                        << " does not belong to any function\n";
    return;
  }

  disassemble_info dinfo;

  init_disassemble_info(&dinfo,NULL,coda_fprintf);
  dinfo.flavour =  bfd_target_elf_flavour;
  dinfo.arch = bfd_arch_i386;
  dinfo.mach = bfd_mach_x86_64;
  dinfo.octets_per_byte = 1;
  dinfo.display_endian = BFD_ENDIAN_LITTLE;

  ObjectEntry *oe = FindObjectEntry(fi->pc);
  if (!oe) {
    std::cout << "Disassembly failed: "<< "0x"<< std::hex << va 
              << " could not be located in the"  
              << (IsMiniDump()?" mini ":" ") <<  "coredump\n";
    return;
  }
  unsigned int buffsize = fi->pc_end - fi->pc;
  unsigned char *buff = new unsigned char[buffsize];

  off_t func_offset = (fi->pc - oe->phdr->p_vaddr)
                                 + oe->phdr->p_offset;
  m_corefile >> File::Offset(func_offset) >> File::Units(buffsize)>> buff;

  dinfo.buffer = buff;
  dinfo.buffer_vma = fi->pc;
  dinfo.buffer_length = buffsize;
 
  start_disassembly(fi->pc,fi->pc_end, &dinfo, m_interactive_mode);
  delete [] buff;
#endif
}

void
CoreObject::ShowIfMinidump()
{
  if (IsMiniDump())
  {
    std::cout << "Mini core dump" << std::endl;
  }
  else
  {
    std::cout << "Full core dump" << std::endl;
  }
}

int 
CoreObject::ShowStrings(char *regex)
{
  regex_t reg;
  int r;

  if (regex != NULL && (r = regcomp(&reg, regex, REG_NOSUB|REG_EXTENDED)))
  {
    char errbuf[256];
    regerror(r, &reg, errbuf, sizeof(errbuf));
    std::cout << "RegEx ERROR:" << errbuf << std::endl;
    return 1;
  }

  return ExtractStringsFromCoredump(regex? &reg : NULL);
}

static inline
int pattern_matched(regex_t *reg, char *str)
{
  if (!reg || regexec(reg, str, 0, NULL, 0) != REG_NOMATCH)
    return 1;
  return 0;
}

int
CoreObject::ExtractStringsFromCoredump(regex_t *reg)
{

  char s_buff[8192];
  static char *d_buff =  (char*)malloc(1 * 1024 * 1024);
  off_t start = 0; 
  off_t end = m_corefile.Size(); 
  off_t min_str_size = 0;
  int readsize = 8192;
  int s_idx = 0;
  int d_idx = 0;
  int lines = 0;
  int write_size = reg?(1024*1024):8192;
  bool new_line = false;

  if (end == -1)  
  {
    std::cout << "Not able to determine core file size." << std::endl;
    return 1;
  }
    
  m_corefile >> File::Offset(0);
  while(1)
  {
    bool break_loop = false;
    if ((end - start) < readsize) {
      readsize = end - start;
      break_loop = true;
    }
    m_corefile >> File::Units(readsize)>> s_buff;
    start += readsize;
    s_idx = 0;
    while(s_idx < readsize)
    {
      if (isprint(s_buff[s_idx]) || isblank(s_buff[s_idx]))
      {
        d_buff[d_idx++] =  s_buff[s_idx];
        min_str_size++;
      }
      else if (min_str_size < MIN_STR_SIZE)
      {
        d_idx -= min_str_size;
        min_str_size = 0;
      }
      else {
        d_buff[d_idx++] = '\n';
        new_line = true;
        min_str_size = 0;
      }

      if ((d_idx == (write_size-1)) || new_line)
      {
        new_line = false;
        d_buff[d_idx] = '\0';
        if(pattern_matched(reg,d_buff))
        {
          std::cout << d_buff;
          Paginate(m_interactive_mode,++lines);
        }
        d_idx = 0;
      }
      ++s_idx;
    }
    if (break_loop)
      break;
  }
  if (d_idx)
  {
    d_buff[d_idx] = '\0';
    if(pattern_matched(reg,d_buff))
      std::cout << d_buff;
  }
  return 0;
}
